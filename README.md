I followed the instructions to the best of my ability. Whenever I got stuck, I followed the terminal's prompts. If those were difficult to understand, I Googled the error messages. It was a great learning experience; although I struggled, I ultimately made it work.
I started by creating a repository on GitHub. I followed the naming conventions and then cloned the empty repository to my local folder using the VS Code terminal. Next, I used the touch command to create the HTML and CSS files, following the instructions specifically to trigger a merge conflict.
While I stayed faithful to the posted instructions, it was challenging to move forward when I had to switch from a feature branch back to main. Since I did not have a main branch to begin with, I had to create one using terminal commands. Once the main branch was established, I could switch between branches. However, when switching branches, I could only see the files specific to that branch. It was challenging to modify different features at the same time, so I used critical thinking and creativity. I imagined what would be in the other branch and intentionally added overlapping code. For instance, in the footer branch, I changed something in the header area. I did the same for the navigation feature, hoping to trigger a conflict during the merge due to the overlapping code.

This successfully triggered the conflict, which I manually resolved before proceeding. After pushing the changes to the GitHub repository, I created the review/main branch online. I realized both of my features were present. I returned to VS Code to make a final change, then added, committed and pushed the work. Finally, I went back to GitHub and submitted the pull request, which was a fun process. The pull request process was essential for ensuring code quality because it acted as a final checkpoint before merging changes into the main project. It allowed me to review my own work in a new environment, identifying where the features might overlap or break. Furthermore, it facilitates collaboration by providing a structured space for peers to leave feedback or catch errors I might have missed, ensuring that only the most stable and high-quality code is integrated. A few days later, I reviewed a peer's work through their public repository. I am uploading this reflection to my README file and including a screenshot of my peer review to complete the assignment.